---
phase: 03-state-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ScreenSort/Services/ProcessedScreenshotStore.swift
  - ScreenSort/ViewModels/ProcessingViewModel.swift
autonomous: true

must_haves:
  truths:
    - "ProcessedScreenshotStore singleton exists and follows CorrectionStore pattern"
    - "Processed IDs persist as Set<String> in UserDefaults"
    - "ProcessingResultItem and Status enum conform to Codable"
    - "Results can be encoded/decoded without data loss"
  artifacts:
    - path: "ScreenSort/Services/ProcessedScreenshotStore.swift"
      provides: "Persistence singleton for processed IDs and results"
      contains: "static let shared"
    - path: "ScreenSort/ViewModels/ProcessingViewModel.swift"
      provides: "Codable conformance for ProcessingResultItem and Status"
      contains: "Codable"
  key_links:
    - from: "ProcessedScreenshotStore"
      to: "UserDefaults"
      via: "JSONEncoder/JSONDecoder"
      pattern: "UserDefaults\\.standard\\.(data|set)"
    - from: "ProcessingResultItem"
      to: "Codable"
      via: "protocol conformance"
      pattern: "struct ProcessingResultItem.*Codable"
---

<objective>
Create persistence infrastructure for tracking processed screenshots and storing results.

Purpose: This enables PERSIST-01 through PERSIST-04 by providing the storage layer that the ViewModel will use. ProcessedScreenshotStore follows the established CorrectionStore pattern. ProcessingResultItem needs Codable conformance to serialize results.

Output:
- ProcessedScreenshotStore.swift - Singleton with markAsProcessed(), isProcessed(), loadProcessedIDs(), saveResults(), loadResults(), cleanupDeletedAssets()
- Modified ProcessingResultItem - Codable conformance with explicit UUID encoding
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-state-persistence/03-RESEARCH.md

# Existing pattern to follow
@ScreenSort/Services/CorrectionStore.swift

# Contains ProcessingResultItem to make Codable
@ScreenSort/ViewModels/ProcessingViewModel.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProcessedScreenshotStore singleton</name>
  <files>ScreenSort/Services/ProcessedScreenshotStore.swift</files>
  <action>
Create a new file `ProcessedScreenshotStore.swift` following the CorrectionStore pattern:

1. Make it `final class ProcessedScreenshotStore: Sendable` with `static let shared` singleton
2. Define storage keys:
   - `ScreenSort.ProcessedIDs` for Set<String> (stored as Array)
   - `ScreenSort.CachedResults` for [ProcessingResultItem]

3. Implement ID tracking methods:
   - `markAsProcessed(_ assetId: String)` - adds to set, saves immediately
   - `isProcessed(_ assetId: String) -> Bool` - checks set membership
   - `loadProcessedIDs() -> Set<String>` - loads from UserDefaults, converts Array to Set
   - Private `saveProcessedIDs(_ ids: Set<String>)` - converts Set to Array, saves

4. Implement results persistence:
   - `saveResults(_ results: [ProcessingResultItem])` - JSONEncoder to UserDefaults
   - `loadResults() -> [ProcessingResultItem]` - JSONDecoder from UserDefaults, returns [] on failure

5. Implement cache invalidation:
   - `cleanupDeletedAssets()` - Uses PHAsset.fetchAssets(withLocalIdentifiers:) to check which stored IDs still exist. Removes stale IDs from both processedIDs set and cached results. Only runs if processedIDs is non-empty.

Import Photos framework for PHAsset access.

Match CorrectionStore style: private init(), print statements for errors with consistent prefix.
  </action>
  <verify>
File exists at ScreenSort/Services/ProcessedScreenshotStore.swift and contains:
- `static let shared = ProcessedScreenshotStore()`
- `func markAsProcessed`
- `func isProcessed`
- `func saveResults`
- `func loadResults`
- `func cleanupDeletedAssets`
- `import Photos`
  </verify>
  <done>
ProcessedScreenshotStore.swift exists with full singleton API matching CorrectionStore pattern. All six public methods implemented. Uses UserDefaults for persistence.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Codable conformance to ProcessingResultItem</name>
  <files>ScreenSort/ViewModels/ProcessingViewModel.swift</files>
  <action>
Modify ProcessingResultItem struct (at bottom of ProcessingViewModel.swift) to support Codable:

1. Add Codable to protocol conformance:
   `struct ProcessingResultItem: Identifiable, Codable, Sendable`

2. Add Codable to Status enum:
   `enum Status: String, Codable, Sendable`
   The `: String` raw value enables automatic Codable synthesis.

3. Fix UUID round-trip issue - change from computed property to stored:
   Change `let id = UUID()` to just `let id: UUID`

4. Add explicit memberwise initializer that generates UUID:
   ```swift
   init(
       assetId: String,
       status: Status,
       contentType: ScreenshotType,
       title: String?,
       creator: String?,
       message: String,
       serviceLink: String?
   ) {
       self.id = UUID()
       self.assetId = assetId
       self.status = status
       self.contentType = contentType
       self.title = title
       self.creator = creator
       self.message = message
       self.serviceLink = serviceLink
   }
   ```

This ensures UUID is included in Codable encoding/decoding and maintains the same call sites.

Note: ScreenshotType already conforms to Codable (check existing code - it uses raw String values).
  </action>
  <verify>
Build succeeds: `xcodebuild -project ScreenSort.xcodeproj -scheme ScreenSort -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20`

Check that ProcessingResultItem has:
- `Codable` in protocol list
- Status enum has `String, Codable`
- `let id: UUID` (not `let id = UUID()`)
- Explicit init that sets `self.id = UUID()`
  </verify>
  <done>
ProcessingResultItem and Status conform to Codable. UUID persists correctly through encode/decode cycle. Build succeeds with no Codable-related errors.
  </done>
</task>

</tasks>

<verification>
1. Both files exist and compile without errors
2. ProcessedScreenshotStore follows CorrectionStore singleton pattern
3. ProcessingResultItem can be encoded and decoded (implicit - build succeeds)
4. No changes to existing functionality (all call sites still work)
</verification>

<success_criteria>
- ProcessedScreenshotStore.swift exists in Services folder
- ProcessingResultItem + Status conform to Codable
- Build succeeds with `xcodebuild build`
- Ready for 03-02 to integrate persistence into ViewModel
</success_criteria>

<output>
After completion, create `.planning/phases/03-state-persistence/03-01-SUMMARY.md`
</output>
