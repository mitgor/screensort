---
phase: 03-state-persistence
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - ScreenSort/ViewModels/ProcessingViewModel.swift
autonomous: true

must_haves:
  truths:
    - "Previously processed screenshots are skipped on reprocessing"
    - "Results survive app termination and display on relaunch"
    - "Stale cache entries are cleaned up on app launch"
    - "Each screenshot is marked processed immediately after success"
  artifacts:
    - path: "ScreenSort/ViewModels/ProcessingViewModel.swift"
      provides: "Integration with ProcessedScreenshotStore"
      contains: "ProcessedScreenshotStore.shared"
  key_links:
    - from: "ProcessingViewModel.checkInitialState"
      to: "ProcessedScreenshotStore.loadResults"
      via: "function call on launch"
      pattern: "loadResults\\(\\)"
    - from: "ProcessingViewModel.processNow"
      to: "ProcessedScreenshotStore.markAsProcessed"
      via: "call after each screenshot"
      pattern: "markAsProcessed\\("
    - from: "ProcessingViewModel.processNow"
      to: "ProcessedScreenshotStore.loadProcessedIDs"
      via: "filter for unprocessed"
      pattern: "loadProcessedIDs\\(\\)"
---

<objective>
Integrate ProcessedScreenshotStore into ProcessingViewModel to enable persistence.

Purpose: This completes PERSIST-01 through PERSIST-04 by wiring the store into the ViewModel. Users will see cached results on launch, skip already-processed screenshots, and have stale entries cleaned up.

Output:
- Modified checkInitialState() - Loads cached results and triggers cleanup
- Modified processNow() - Filters unprocessed, marks each as processed, saves results
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-state-persistence/03-RESEARCH.md
@.planning/phases/03-state-persistence/03-01-SUMMARY.md

# Files to modify
@ScreenSort/ViewModels/ProcessingViewModel.swift
@ScreenSort/Services/ProcessedScreenshotStore.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Load cached results on app launch</name>
  <files>ScreenSort/ViewModels/ProcessingViewModel.swift</files>
  <action>
Modify `checkInitialState()` to load cached results and trigger cleanup:

1. After existing setup (photoPermissionStatus, isYouTubeAuthenticated, googleDocURL), add:
   ```swift
   // Load cached results from previous session
   let cachedResults = ProcessedScreenshotStore.shared.loadResults()
   if !cachedResults.isEmpty {
       self.results = cachedResults
   }

   // Clean up stale entries for deleted photos (async, non-blocking)
   Task {
       ProcessedScreenshotStore.shared.cleanupDeletedAssets()
   }
   ```

This ensures:
- Previous results display immediately on launch (PERSIST-03)
- Cleanup runs in background without blocking UI
- Empty results array is not overwritten with empty cache
  </action>
  <verify>
Check that checkInitialState contains:
- `ProcessedScreenshotStore.shared.loadResults()`
- `self.results = cachedResults`
- `cleanupDeletedAssets()` call in Task block
  </verify>
  <done>
checkInitialState loads cached results on launch and triggers async cleanup. Users see previous session results immediately.
  </done>
</task>

<task type="auto">
  <name>Task 2: Filter and persist during processing</name>
  <files>ScreenSort/ViewModels/ProcessingViewModel.swift</files>
  <action>
Modify `processNow()` to use persistence:

1. REPLACE the existing caption-based filtering with ID-based filtering. Find this block:
   ```swift
   let screenshots = allScreenshots.filter { asset in
       guard let caption = photoService.getCaption(for: asset) else { return true }
       return !caption.hasPrefix(captionPrefix)
   }
   ```

   Replace with:
   ```swift
   let processedIDs = ProcessedScreenshotStore.shared.loadProcessedIDs()
   let screenshots = allScreenshots.filter { asset in
       !processedIDs.contains(asset.localIdentifier)
   }
   ```

   Note: Keep the caption-based filtering as a SECONDARY filter (belt + suspenders):
   ```swift
   let processedIDs = ProcessedScreenshotStore.shared.loadProcessedIDs()
   let screenshots = allScreenshots.filter { asset in
       // Skip if already in persisted processed set
       guard !processedIDs.contains(asset.localIdentifier) else { return false }
       // Also skip if caption indicates already processed (legacy check)
       if let caption = photoService.getCaption(for: asset), caption.hasPrefix(captionPrefix) {
           return false
       }
       return true
   }
   ```

2. Inside the processing loop, AFTER `results.append(result)`, add:
   ```swift
   // Mark as processed immediately (survives crash)
   ProcessedScreenshotStore.shared.markAsProcessed(asset.localIdentifier)
   ```

3. AFTER the processing loop completes (after `await processingTask?.value`), add:
   ```swift
   // Save results for display on next launch
   if !results.isEmpty {
       ProcessedScreenshotStore.shared.saveResults(results)
   }
   ```

This ensures:
- PERSIST-01: App tracks which screenshots have been processed
- PERSIST-02: Previously processed screenshots are skipped
- PERSIST-03: Results persist between launches (saved after each batch)
- Crash safety: Each screenshot marked processed immediately after success
  </action>
  <verify>
Check that processNow contains:
- `ProcessedScreenshotStore.shared.loadProcessedIDs()`
- `!processedIDs.contains(asset.localIdentifier)` in filter
- `ProcessedScreenshotStore.shared.markAsProcessed(` inside processing loop
- `ProcessedScreenshotStore.shared.saveResults(results)` after loop
  </verify>
  <done>
processNow filters by persisted IDs, marks each screenshot processed immediately, and saves results after batch. Supports PERSIST-01, PERSIST-02, PERSIST-03.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify full persistence flow</name>
  <files>ScreenSort/ViewModels/ProcessingViewModel.swift</files>
  <action>
Add a debug log to confirm persistence is working (can be removed later):

1. In checkInitialState, after loading cached results:
   ```swift
   print("[ProcessingViewModel] Loaded \(cachedResults.count) cached results, \(ProcessedScreenshotStore.shared.loadProcessedIDs().count) processed IDs")
   ```

2. In processNow, after filtering:
   ```swift
   print("[ProcessingViewModel] Skipped \(processedIDs.count) already-processed screenshots")
   ```

3. Build and run basic verification:
   - Build succeeds
   - No runtime crashes
   - Logs show expected behavior
  </action>
  <verify>
Build succeeds: `xcodebuild -project ScreenSort.xcodeproj -scheme ScreenSort -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20`

Debug logs added for:
- Cached results count on launch
- Processed IDs count on launch
- Skipped count during processing
  </verify>
  <done>
Full persistence flow integrated and verified. Build succeeds. Debug logs confirm flow works as expected.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds with no errors
2. checkInitialState loads cached results and triggers cleanup
3. processNow filters by persisted IDs
4. Each screenshot marked processed immediately after success
5. Results saved after processing batch completes
6. Debug logs confirm expected behavior
</verification>

<success_criteria>
- All PERSIST requirements addressed:
  - PERSIST-01: Processed IDs tracked via markAsProcessed()
  - PERSIST-02: loadProcessedIDs() used in filter
  - PERSIST-03: saveResults() called, loadResults() on launch
  - PERSIST-04: cleanupDeletedAssets() called on launch
- Build succeeds
- Ready for Phase 3 verification
</success_criteria>

<output>
After completion, create `.planning/phases/03-state-persistence/03-02-SUMMARY.md`
</output>
