---
phase: 04-launch-experience
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - ScreenSort/Views/ProcessingView.swift
autonomous: true

must_haves:
  truths:
    - "User's scroll position is restored when app relaunches"
    - "Scroll position is saved when leaving the view (not during scroll)"
    - "Scroll restoration works with LazyVStack and stable item IDs"
  artifacts:
    - path: "ScreenSort/Views/ProcessingView.swift"
      provides: "ScrollPosition binding and @AppStorage for scroll ID"
      contains: "@AppStorage"
      contains: "scrollPosition"
  key_links:
    - from: "ProcessingView.swift"
      to: "UserDefaults (via @AppStorage)"
      via: "Persist scroll position ID"
      pattern: "@AppStorage.*scrolledResultId"
    - from: "ScrollView"
      to: "scrollPosition"
      via: ".scrollPosition($scrollPosition)"
      pattern: "\\.scrollPosition\\("
---

<objective>
Implement scroll position persistence to restore user's scroll position across app launches.

Purpose: LAUNCH-03 requires the app to restore scroll position and view state from previous session. Users scrolling through results should return to their position when reopening the app.

Output: Scroll position persists via @AppStorage and restores on app launch.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-launch-experience/04-RESEARCH.md
@.planning/phases/04-launch-experience/04-01-SUMMARY.md

@ScreenSort/Views/ProcessingView.swift
@ScreenSort/ViewModels/ProcessingViewModel.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scroll position state and persistence</name>
  <files>ScreenSort/Views/ProcessingView.swift</files>
  <action>
1. Add @AppStorage property at the top of ProcessingView struct:
```swift
@AppStorage("ScreenSort.LastScrolledResultId") private var lastScrolledResultId: String = ""
```

2. Add @State for ScrollPosition:
```swift
@State private var scrollPosition = ScrollPosition(idType: String.self)
```

3. Add @State to track the current visible item ID (for saving on disappear):
```swift
@State private var currentTopItemId: String = ""
```

Note: Use iOS 18's ScrollPosition API. The project already targets iOS 18.1+.
  </action>
  <verify>Build succeeds with `xcodebuild -scheme ScreenSort -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20`</verify>
  <done>ProcessingView has @AppStorage for scroll ID, @State for ScrollPosition, and @State for currentTopItemId</done>
</task>

<task type="auto">
  <name>Task 2: Wire scroll position to results ScrollView</name>
  <files>ScreenSort/Views/ProcessingView.swift</files>
  <action>
1. In resultsSection, find the inner ScrollView that wraps the LazyVStack. Add scrollTargetLayout() to the LazyVStack:
```swift
LazyVStack(spacing: 0) {
    ForEach(...) { result in
        CompactResultRow(result: result)
            .id(result.id.uuidString)  // Use stable UUID string as ID
        Divider()
            .padding(.horizontal, AppTheme.spacingSM)
    }
}
.scrollTargetLayout()
```

2. Add .scrollPosition binding to the ScrollView in resultsSection:
```swift
ScrollView {
    // LazyVStack content
}
.scrollPosition($scrollPosition)
.frame(maxHeight: 300)
```

3. Add .task modifier to restore scroll position on appear (after results load):
```swift
.task {
    // Only restore if we have a saved position and results exist
    if !lastScrolledResultId.isEmpty && !viewModel.successResults.isEmpty {
        // Small delay to ensure list is laid out
        try? await Task.sleep(for: .milliseconds(100))
        scrollPosition.scrollTo(id: lastScrolledResultId, anchor: .top)
    }
}
```

4. Add .onDisappear modifier to save scroll position (debounced - only on disappear):
```swift
.onDisappear {
    if !currentTopItemId.isEmpty {
        lastScrolledResultId = currentTopItemId
    }
}
```

5. Add .onChange to track scroll position changes:
```swift
.onChange(of: scrollPosition.viewID(type: String.self)) { _, newId in
    if let id = newId {
        currentTopItemId = id
    }
}
```

Note: Per research, save on disappear rather than during scroll to avoid excessive UserDefaults writes (onScrollGeometryChange fires 60-120 times per second).
  </action>
  <verify>Build succeeds with `xcodebuild -scheme ScreenSort -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20`</verify>
  <done>Scroll position binds to ScrollView, saves on disappear, restores on appear</done>
</task>

</tasks>

<verification>
1. Build succeeds without errors
2. Code inspection confirms:
   - @AppStorage stores scroll position ID
   - ScrollPosition binding applied to results ScrollView
   - .scrollTargetLayout() applied to LazyVStack
   - Each result row has stable .id() using UUID string
   - Position saves on disappear, restores on appear
3. No writes occur during scrolling (debounced via onDisappear pattern)
</verification>

<success_criteria>
- @AppStorage persists scroll position ID to UserDefaults
- ScrollPosition binding enables programmatic scroll control
- LazyVStack has scrollTargetLayout() for scroll tracking
- Scroll position saves on view disappear
- Scroll position restores on view appear
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-launch-experience/04-02-SUMMARY.md`
</output>
