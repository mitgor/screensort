---
phase: 04-launch-experience
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - ScreenSort/ViewModels/ProcessingViewModel.swift
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User sees skeleton/placeholder UI while fresh data loads in background"
    - "User launches app and immediately sees previous session's results, then new screenshots load in background"
    - "isRefreshing flag is set true when background refresh starts and false when it completes"
  artifacts:
    - path: "ScreenSort/ViewModels/ProcessingViewModel.swift"
      provides: "refreshInBackground() method that processes only new screenshots"
      contains: "refreshInBackground"
    - path: "ScreenSort/ViewModels/ProcessingViewModel.swift"
      provides: "isRefreshing lifecycle management"
      pattern: "isRefreshing = true"
  key_links:
    - from: "checkInitialState()"
      to: "refreshInBackground()"
      via: "Task call after loading cached results"
      pattern: "Task.*refreshInBackground"
    - from: "refreshInBackground()"
      to: "isRefreshing"
      via: "Set true at start, false at end"
      pattern: "isRefreshing = (true|false)"
---

<objective>
Close verification gaps: wire isRefreshing flag lifecycle and add background refresh method.

Purpose: Verification found that isRefreshing exists but is never set to true (LAUNCH-02 blocked) and there's no way to detect new screenshots without clearing existing results (LAUNCH-01 partial). This plan adds the missing pieces to make skeleton UI functional and enable background refresh.

Output: App launches with cached results instantly, triggers background refresh for new screenshots, skeleton UI displays during refresh.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-launch-experience/04-VERIFICATION.md

@ScreenSort/ViewModels/ProcessingViewModel.swift
@ScreenSort/Services/ProcessedScreenshotStore.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add refreshInBackground() method for processing new screenshots</name>
  <files>ScreenSort/ViewModels/ProcessingViewModel.swift</files>
  <action>
Add a new method `refreshInBackground()` to ProcessingViewModel that:

1. Checks for new screenshots WITHOUT clearing existing results
2. Sets `isRefreshing = true` at the start (this enables skeleton UI)
3. Processes only unprocessed screenshots (filter using ProcessedScreenshotStore.shared.loadProcessedIDs())
4. Appends new results to existing `results` array (do NOT clear)
5. Sets `isRefreshing = false` when done (in defer block)

Implementation:

```swift
// MARK: - Background Refresh

/// Checks for and processes new screenshots in background without clearing existing results.
/// Sets isRefreshing to enable skeleton UI when no results exist.
func refreshInBackground() async {
    guard hasPhotoAccess else { return }
    guard isYouTubeAuthenticated else { return }
    guard !isProcessing else { return }  // Don't refresh during full processing

    // Only show skeleton if we have no results to display
    if results.isEmpty {
        isRefreshing = true
    }

    defer {
        isRefreshing = false
    }

    do {
        // Fetch all screenshots
        let allScreenshots = try await photoService.fetchScreenshots()

        // Filter to only unprocessed ones
        let processedIDs = ProcessedScreenshotStore.shared.loadProcessedIDs()
        let newScreenshots = allScreenshots.filter { asset in
            !processedIDs.contains(asset.localIdentifier)
        }

        guard !newScreenshots.isEmpty else {
            print("[ProcessingViewModel] No new screenshots to refresh")
            return
        }

        print("[ProcessingViewModel] Background refresh: \(newScreenshots.count) new screenshots")

        // Get/create playlist for music screenshots
        let playlistId = try await youtubeService.getOrCreatePlaylist(named: playlistName)

        // Process each new screenshot
        for asset in newScreenshots {
            let result = await processScreenshot(asset: asset, playlistId: playlistId)
            results.append(result)
            ProcessedScreenshotStore.shared.markAsProcessed(asset.localIdentifier)
        }

        // Save updated results
        if !results.isEmpty {
            ProcessedScreenshotStore.shared.saveResults(results)
        }

    } catch {
        print("[ProcessingViewModel] Background refresh error: \(error.localizedDescription)")
    }
}
```

Place this method after checkInitialState() and before requestPhotoAccess() to keep related lifecycle methods together.

Key differences from processNow():
- Does NOT set `results = []` (preserves cached results)
- Does NOT set `isProcessing = true` (allows UI to remain interactive)
- Does NOT disable idle timer (lightweight background operation)
- Only sets `isRefreshing = true` when results are empty (skeleton shows only when needed)
  </action>
  <verify>Build succeeds with `xcodebuild -scheme ScreenSort -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20`</verify>
  <done>refreshInBackground() method exists, sets isRefreshing = true at start (when results empty), processes only new screenshots, sets isRefreshing = false when done</done>
</task>

<task type="auto">
  <name>Task 2: Trigger background refresh after loading cached results</name>
  <files>ScreenSort/ViewModels/ProcessingViewModel.swift</files>
  <action>
In checkInitialState(), after loading cached results and starting the cleanup task, add a call to trigger background refresh:

Find this existing code block (around line 144-148):
```swift
// Clean up stale entries for deleted photos (async, non-blocking)
Task {
    ProcessedScreenshotStore.shared.cleanupDeletedAssets()
}
```

Modify to also trigger background refresh after cleanup:
```swift
// Clean up stale entries, then check for new screenshots
Task {
    ProcessedScreenshotStore.shared.cleanupDeletedAssets()
    await refreshInBackground()
}
```

This ensures:
1. Cached results display immediately (synchronous load - unchanged)
2. Cleanup runs first (removes deleted asset references)
3. Background refresh runs second (discovers new screenshots)
4. If results are empty after cache load, skeleton shows during refresh

Do NOT add any delay before refreshInBackground() - the method already handles the skeleton display condition.
  </action>
  <verify>Build succeeds with `xcodebuild -scheme ScreenSort -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20`</verify>
  <done>checkInitialState() calls refreshInBackground() after cleanup task completes</done>
</task>

</tasks>

<verification>
1. Build succeeds without errors
2. Code inspection confirms:
   - refreshInBackground() method exists
   - isRefreshing = true is set at start (when results empty)
   - isRefreshing = false is set in defer block
   - New screenshots are appended to results (not replacing)
   - checkInitialState() triggers refreshInBackground() in Task
3. Grep confirms isRefreshing is now set to true somewhere:
   `grep -n "isRefreshing = true" ScreenSort/ViewModels/ProcessingViewModel.swift`
</verification>

<success_criteria>
- isRefreshing = true appears in codebase (gap 1 closed)
- refreshInBackground() method processes only unprocessed screenshots (gap 2 closed)
- Background refresh triggers automatically after cached results load
- Existing results preserved during background refresh
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-launch-experience/04-03-SUMMARY.md`
</output>
